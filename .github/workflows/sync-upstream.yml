name: sync-upstream

on:
  # schedule:
  #   - cron: "0 7 * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: Perform a no-op dry run
        type: boolean
        default: false
      force_retag:
        description: Force re-tag if tag exists on remote
        type: boolean
        default: false

concurrency:
  group: sync-upstream
  cancel-in-progress: false

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: python

      - uses: extractions/setup-just@v2

      - name: Configure git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Add remotes and fetch
        run: |
          git remote add upstream https://github.com/parcel-bundler/lightningcss || true
          git fetch upstream --tags --prune
          git fetch origin --tags --prune

      - name: Record initial HEAD
        id: head
        run: echo "sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Compute ahead/behind vs upstream/master
        id: ab
        run: |
          BASE=$(git merge-base HEAD upstream/master)
          BEHIND=$(git rev-list --left-only --count HEAD...upstream/master)
          AHEAD=$(git rev-list --right-only --count HEAD...upstream/master)
          echo "base=$BASE"   >> "$GITHUB_OUTPUT"
          echo "behind=$BEHIND" >> "$GITHUB_OUTPUT"
          echo "ahead=$AHEAD"   >> "$GITHUB_OUTPUT"

      - name: Plan merge (dry-run)
        if: ${{ inputs.dry_run && steps.ab.outputs.behind != '0' }}
        run: echo "Would merge upstream/master into python (behind=${{ steps.ab.outputs.behind }})"

      - name: Merge upstream/master into python
        if: ${{ !inputs.dry_run && steps.ab.outputs.behind != '0' }}
        run: |
          set -e
          if ! git merge upstream/master -X ours --no-edit; then
            echo "Merge failed, attempting rebase with theirs"
            git merge --abort || true
            git rebase upstream/master -X theirs
          fi

      - name: Check if version update needed
        id: ver
        run: |
          NEED=$(just needs-version-update)
          echo "needed=$NEED" >> "$GITHUB_OUTPUT"

      - name: Plan version update (dry-run)
        if: ${{ inputs.dry_run && steps.ver.outputs.needed == 'change' }}
        run: echo "Would update pyproject.toml version via 'just update-metadata'"

      - name: Update pyproject from package.json
        if: ${{ !inputs.dry_run && steps.ver.outputs.needed == 'change' }}
        run: |
          just update-metadata
          if [[ -n $(git status --porcelain) ]]; then
            git add pyproject.toml
            git commit -m "sync version from package.json to pyproject.toml"
          fi

      - name: Determine latest upstream version tag
        id: latest
        run: |
          LATEST_TAG=$(git tag -l --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n1)
          if [[ -z "$LATEST_TAG" ]]; then
            echo "No tags found" >&2
            exit 1
          fi
          echo "latest=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Plan tag action (dry-run)
        if: ${{ inputs.dry_run }}
        run: |
          VERSION=${{ steps.latest.outputs.latest }}
          HEADSHA=$(git rev-parse HEAD)
          LOCAL_TAG_SHA=$(git rev-parse -q --verify "refs/tags/$VERSION^{commit}" || true)
          if git ls-remote --tags origin "$VERSION^{}" | grep -q "$VERSION"; then
            if [[ "${{ inputs.force_retag }}" == "true" ]]; then
              echo "Tag $VERSION exists on origin; would retag to HEAD ($HEADSHA) and force-push"
            else
              echo "Tag $VERSION already exists on origin; would not create"
            fi
          else
            if [[ -n "$LOCAL_TAG_SHA" ]]; then
              if [[ "$LOCAL_TAG_SHA" == "$HEADSHA" ]]; then
                echo "Local tag $VERSION points to HEAD; would push tag"
              else
                echo "Local tag $VERSION at $LOCAL_TAG_SHA (not HEAD); would skip push. Re-run with force_retag=true to move it."
              fi
            else
              echo "Would create and push tag $VERSION at current HEAD ($HEADSHA)"
            fi
          fi

      - name: Ensure tag exists on current HEAD
        if: ${{ !inputs.dry_run }}
        run: |
          set -euo pipefail
          VERSION=${{ steps.latest.outputs.latest }}
          HEADSHA=$(git rev-parse HEAD)
          LOCAL_TAG_SHA=$(git rev-parse -q --verify "refs/tags/$VERSION^{commit}" || true)
          REMOTE_HAS_TAG=$(git ls-remote --tags origin "$VERSION^{}" | grep -q "$VERSION" && echo yes || echo no)

          if [[ "$REMOTE_HAS_TAG" == "yes" ]]; then
            if [[ "${{ inputs.force_retag }}" == "true" ]]; then
              echo "Force retagging $VERSION to $HEADSHA"
              git tag -f "$VERSION" "$HEADSHA"
            else
              echo "Tag $VERSION exists on origin; leaving as-is"
            fi
          else
            if [[ -n "$LOCAL_TAG_SHA" ]]; then
              if [[ "$LOCAL_TAG_SHA" == "$HEADSHA" ]]; then
                echo "Local tag $VERSION already at HEAD"
              else
                if [[ "${{ inputs.force_retag }}" == "true" ]]; then
                  echo "Retagging local $VERSION from $LOCAL_TAG_SHA to $HEADSHA"
                  git tag -f "$VERSION" "$HEADSHA"
                else
                  echo "Local $VERSION at $LOCAL_TAG_SHA (not HEAD). Skipping retag; re-run with force_retag=true to move it."
                fi
              fi
            else
              echo "Creating tag $VERSION at $HEADSHA"
              git tag "$VERSION" "$HEADSHA"
            fi
          fi

      - name: Plan push (dry-run)
        if: ${{ inputs.dry_run }}
        run: |
          if [[ "${{ steps.head.outputs.sha }}" != "$(git rev-parse HEAD)" ]]; then
            echo "Would push branch python"
          else
            echo "No branch changes to push"
          fi
          VERSION=${{ steps.latest.outputs.latest }}
          if ! git ls-remote --tags origin "$VERSION^{}" | grep -q "$VERSION"; then
            echo "Would push tag $VERSION"
          else
            echo "No tag push needed"
          fi

      - name: Push branch and/or tag
        if: ${{ !inputs.dry_run }}
        run: |
          set -euo pipefail
          CHANGED=$(test "${{ steps.head.outputs.sha }}" != "$(git rev-parse HEAD)" && echo yes || echo no)
          if [[ "$CHANGED" == "yes" ]]; then
            git push origin python
          else
            echo "Branch unchanged; not pushing python"
          fi

          VERSION=${{ steps.latest.outputs.latest }}
          HEADSHA=$(git rev-parse HEAD)
          LOCAL_TAG_SHA=$(git rev-parse -q --verify "refs/tags/$VERSION^{commit}" || true)

          if [[ -z "$LOCAL_TAG_SHA" ]]; then
            echo "No local tag $VERSION; skipping tag push"
            exit 0
          fi

          if git ls-remote --tags origin "$VERSION^{}" | grep -q "$VERSION"; then
            if [[ "${{ inputs.force_retag }}" == "true" ]]; then
              echo "Pushing forced tag $VERSION"
              git push -f origin "$VERSION"
            else
              echo "Remote already has $VERSION; skipping tag push"
            fi
          else
            if [[ "$LOCAL_TAG_SHA" == "$HEADSHA" ]]; then
              echo "Pushing new tag $VERSION"
              git push origin "$VERSION"
            else
              echo "Local tag $VERSION is not at HEAD ($LOCAL_TAG_SHA vs $HEADSHA); skipping push. Re-run with force_retag=true to move."
            fi
          fi
