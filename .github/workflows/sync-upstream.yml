name: sync-upstream

on:
  # schedule:
  #   - cron: "0 7 * * *"
  workflow_dispatch:
    inputs:
      dry_run:
        description: Perform a no-op dry run
        type: boolean
        default: false

concurrency:
  group: sync-upstream
  cancel-in-progress: false

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: python

      - uses: extractions/setup-just@v2

      - name: Configure git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Add remotes and fetch
        run: |
          git remote add upstream https://github.com/parcel-bundler/lightningcss || true
          git fetch upstream --tags --prune
          git fetch origin --tags --prune

      - name: Record initial HEAD
        id: head
        run: echo "sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Compute ahead/behind vs upstream/master
        id: ab
        run: |
          BASE=$(git merge-base HEAD upstream/master)
          BEHIND=$(git rev-list --left-only --count HEAD...upstream/master)
          AHEAD=$(git rev-list --right-only --count HEAD...upstream/master)
          echo "base=$BASE"   >> "$GITHUB_OUTPUT"
          echo "behind=$BEHIND" >> "$GITHUB_OUTPUT"
          echo "ahead=$AHEAD"   >> "$GITHUB_OUTPUT"

      - name: Merge upstream/master into python
        if: ${{ steps.ab.outputs.behind != '0' }}
        run: |
          set -e
          if ! git merge upstream/master -X ours --no-edit; then
            echo "Merge failed, attempting rebase with theirs"
            git merge --abort || true
            git rebase upstream/master -X theirs
          fi

      - name: Check if version update needed
        id: ver
        run: |
          NEED=$(just needs-version-update)
          echo "needed=$NEED" >> "$GITHUB_OUTPUT"

      - name: Update pyproject from package.json
        if: ${{ steps.ver.outputs.needed == 'change' }}
        run: |
          just update-metadata
          if [[ -n $(git status --porcelain) ]]; then
            git add pyproject.toml
            git commit -m "sync version from package.json to pyproject.toml"
          fi

      - name: Determine latest upstream version tag
        id: latest
        run: |
          LATEST_TAG=$(git tag -l --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n1)
          if [[ -z "$LATEST_TAG" ]]; then
            echo "No tags found" >&2
            exit 1
          fi
          echo "latest=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Resolve tag commit sha
        id: tagsha
        run: |
          VERSION=${{ steps.latest.outputs.latest }}
          SHA=$(git ls-remote --tags upstream "$VERSION^{}" | awk '{print $1}')
          if [[ -z "$SHA" ]]; then
            # Fallback to local tag if remote resolution fails
            SHA=$(git rev-parse -q --verify "refs/tags/$VERSION^{commit}" || true)
          fi
          if [[ -z "$SHA" ]]; then
            echo "Could not resolve tag $VERSION to a commit" >&2
            exit 1
          fi
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"

      - name: Checkout upstream tag (detached)
        run: |
          git checkout -q --detach "${{ steps.tagsha.outputs.sha }}"

      - name: Copy packaging files from origin/python
        run: |
          set -euo pipefail
          for f in pyproject.toml README-PYPI.md; do
            if git ls-tree -r --name-only origin/python | grep -qx "$f"; then
              git checkout origin/python -- "$f"
            else
              echo "Warning: $f not found on origin/python; skipping copy"
            fi
          done

      - name: Prepare packaging commit at tag
        run: |
          set -euo pipefail
          VERSION=${{ steps.latest.outputs.latest }}
          just update-metadata
          if [[ -n $(git status --porcelain) ]]; then
            git add pyproject.toml README-PYPI.md || true
            git commit -m "Python packaging for $VERSION"
          else
            echo "No packaging changes to commit at $VERSION"
          fi

      - name: Ensure tag points to packaging commit (tag-on-tag)
        run: |
          set -euo pipefail
          VERSION=${{ steps.latest.outputs.latest }}
          PACKAGING_SHA=$(git rev-parse HEAD)
          LOCAL_TAG_SHA=$(git rev-parse -q --verify "refs/tags/$VERSION^{commit}" || true)
          if [[ -n "$LOCAL_TAG_SHA" && "$LOCAL_TAG_SHA" == "$PACKAGING_SHA" ]]; then
            echo "Local tag $VERSION already points to packaging commit"
          elif [[ -n "$LOCAL_TAG_SHA" ]]; then
            echo "Updating local tag $VERSION to packaging commit $PACKAGING_SHA"
            git tag -f "$VERSION" "$PACKAGING_SHA"
          else
            echo "Creating local tag $VERSION at packaging commit $PACKAGING_SHA"
            git tag "$VERSION" "$PACKAGING_SHA"
          fi

      - name: Plan push (dry-run)
        if: ${{ inputs.dry_run }}
        run: |
          set -euo pipefail
          BRANCH_TIP=$(git rev-parse python)
          if [[ "${{ steps.head.outputs.sha }}" != "$BRANCH_TIP" ]]; then
            echo "Would push branch python"
          else
            echo "No branch changes to push"
          fi
          VERSION=${{ steps.latest.outputs.latest }}
          LOCAL_TAG_SHA=$(git rev-parse -q --verify "refs/tags/$VERSION^{commit}" || true)
          REMOTE_TAG_SHA=$(git ls-remote --tags origin "$VERSION^{}" | awk '{print $1}')
          if [[ -z "$REMOTE_TAG_SHA" ]]; then
            echo "Would push new tag $VERSION ($LOCAL_TAG_SHA)"
          elif [[ "$REMOTE_TAG_SHA" != "$LOCAL_TAG_SHA" ]]; then
            echo "Would force-push tag $VERSION from $REMOTE_TAG_SHA to $LOCAL_TAG_SHA"
          else
            echo "No tag push needed"
          fi

      - name: Push branch and/or tag
        if: ${{ !inputs.dry_run }}
        run: |
          set -euo pipefail
          # Push branch only if python has new commits
          BRANCH_TIP=$(git rev-parse python)
          if [[ "${{ steps.head.outputs.sha }}" != "$BRANCH_TIP" ]]; then
            echo "Pushing branch python"
            git push origin python
          else
            echo "Branch unchanged; not pushing python"
          fi

          VERSION=${{ steps.latest.outputs.latest }}
          LOCAL_TAG_SHA=$(git rev-parse -q --verify "refs/tags/$VERSION^{commit}" || true)
          if [[ -z "$LOCAL_TAG_SHA" ]]; then
            echo "No local tag $VERSION; skipping tag push"
            exit 0
          fi
          REMOTE_TAG_SHA=$(git ls-remote --tags origin "$VERSION^{}" | awk '{print $1}')
          if [[ -z "$REMOTE_TAG_SHA" ]]; then
            echo "Pushing new tag $VERSION"
            git push origin "$VERSION"
          elif [[ "$REMOTE_TAG_SHA" != "$LOCAL_TAG_SHA" ]]; then
            echo "Force-pushing updated tag $VERSION ($REMOTE_TAG_SHA -> $LOCAL_TAG_SHA)"
            git push -f origin "$VERSION"
          else
            echo "Tag $VERSION already up to date on remote"
          fi
